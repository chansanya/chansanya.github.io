---
title: extends 和 super
date: 2023-08-23 10:20:40
permalink: /pages/10f757/
categories:
  - 知识库
  - java
  - 其他
tags:
  - 
author: 
  name: YAN
  link: https://github.com/chansanya
---


extends 和 super

extends 上界：<? extends T> 表示**泛型类型**的上界是T或T的子类型。这意味着你可以读取泛型对象的值，但不能往里面写入。

super 下界：<? super T> 表示**泛型类型**的下界是T或T的父类型。这意味着你可以往泛型对象里写入T类型或T的子类型，但不能读取具体类型。

这里的上下界表示：定义泛型时，**实际类型**的边界

```
    public static class  Food{}

    public static class  Bread extends Food {}

    public static class  Noodles extends Food {}
    
    List<? extends    A> list2 = new ArrayList<?>();
    List<? super   B> list = new ArrayList<?>();
```

在上面示例里 **实际类型`？`**，
上界 `<? extends A>` ，也就是说`？`的范围为,A和A的子类型，

定义了上界，也就是定义了最上级的形态，一旦定义将无法变更。

例如定义了一个 `List<? extends Food>` 最上级形态为 `Food`,

我们给这个列表放置了`Bread`, `List<? extends Food> foods= new ArrayList<Bread>`  

这时候我想要：`foods.add(noodles)` ,`noodles` 继承于 `Bread`，理论上来说这样是没问题的

但是，此时的`foods` 类型为`Bread` 。把 `noodles` 放入 `Bread` 的列表显然不合理。

所以 extends 失去了写入能力


下界 `<? super B>` ，也就是说`？`的范围为,B和B的父类型

定义了上界，也就是定义了最下级的形态,同样用上面的例子

例如定义了一个 `List<? super Food>` 最下级形态为 `Food`,

我在 `Food` 列表里无论是加入`Bread`,`noodles`显然都是合理的。

但是在取出的时候，我无法知道拿到的是什么，我只能知道他们都属于`Food` 

所以 super 失去了获取详细内容的能力


上面这段话分可两部分理解： 泛型类型上下限 ，可写入读取的类型


### 泛型类型上下限示例

示例
```
    public static class  A{}

    public static class  B extends A {}

    @Test
    public void  test(){
        //泛型类型的上限是 A或 A 的子类型
        
        //编译通过 -> 赋值对象泛型A，在泛型访问内
        List<? extends  A> extend1 = new ArrayList<A>();
        
        //编译通过 -> 赋值对象泛型B， B是A的子类，在泛型访问内
        List<? extends  A> extend2 = new ArrayList<B>();
        
        //编译失败 -> 赋值对象泛型Object， Object不是A的子类，不在泛型访问内
        List<? extends  A> extend3 = new ArrayList<Object>();
        
        //编译通过 -> 赋值对象泛型为空，， 默认采用<? extends  A>
        List<? extends  A> extend3 = new ArrayList<>();
        
        
        //泛型类型的下限是 A或A的父类型
        
        //编译通过 ->  赋值对象泛型A，在泛型访问内
        List<? super   A> super1 = new ArrayList<A>();
        
        //编译失败 ->  赋值对象泛型B， B不是A的父类型，不在泛型访问内
        List<? super   A> super2 = new ArrayList<B>();
        
        //编译失败 ->  赋值对象泛型Object， Object不是A的父类型，不在泛型访问内
        List<? super   A> super3 = new ArrayList<Object>();
        
        //编译通过 ->  赋值对象泛型为空，， 默认采用<? super  A>
        List<? super   A> super3 = new ArrayList<>();
    }
```


### 可写入读取的类型示例

#### extends示例

extend 更关注结果
```text
    public void  test(){
        //泛型范围为:A和A的子类型 ，所以A和B类型都是在泛型范围内，所以编译通过
        List<? extends  A> extend = Arrays.asList(new A(),new B());
        
        //由于泛型范围为：A和A的子类型，所以在add的时候,无法确定？是A,B，又或者是其他的C
        //因此写入是不安全的
        extend.add(new A()); // 编译失败
        extend.add(new B()); // 编译失败
        
        //由于泛型上限为A,因此可以安全的获取到结果，编译通过
        extend.forEach(i-> System.out.println(i.getClass()));
     

    }
```


#### super示例

super 更关注参数

```
    public void  test(){
        List<? super   B> super1 = new ArrayList<>();
        //泛型范围为:B和B的父类型，所以List的值可为：B类型和父类型为B的数据 （B和B的子类型）
        
        //编译失败 ->  A是不B的子类型
        super1.add(new A());
        //编译通过 ->  类型为范围下限B
        super1.add(new B());
        
        //泛型类型下限为B,内容：B或B的子类型，
        //因此这里无法获取到具体的数据类型，所以无法获取到准确的对象，只能返回Object
        Object o = super1.get(0);
    }
    
     public void  test2(){        
        List<? super   A> super1 = new ArrayList<>();
        
        //编译通过 ->  类型为范围下限A
        super1.add(new A());
        //编译通过 ->  B是A的子类型
        super1.add(new B());
        
        //泛型类型下限为A,内容：A或A的子类型，
        //因此这里无法获取到具体的数据类型，所以无法获取到准确的对象，只能返回Object
        Object o = super1.get(0);
    }
```

