(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{391:function(t,n,s){"use strict";s.r(n);var a=s(7),e=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"线程状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[t._v("#")]),t._v(" 线程状态")]),t._v(" "),n("ul",[n("li",[t._v("New：新创建的线程，尚未执行；")]),t._v(" "),n("li",[t._v("Runnable：运行中的线程，正在执行run()方法的Java代码；")]),t._v(" "),n("li",[t._v("Blocked：运行中的线程，因为某些操作被阻塞而挂起；")]),t._v(" "),n("li",[t._v("Waiting：运行中的线程，因为某些操作在等待中；")]),t._v(" "),n("li",[t._v("Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；")]),t._v(" "),n("li",[t._v("Terminated：线程已终止，因为run()方法执行完毕。")])]),t._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[t._v("示例")]),t._v(" "),n("p",[n("code",[t._v("join()")]),t._v(" 等待该线程结束，然后才继续往下执行自身线程")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('@Test\npublic  void  case1() throws Exception {\n    Thread t = new Thread(() -> {\n        for (int i = 0; i < 100; i++) {\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    });\n    System.out.println("start() 前，Thread T 状态:"+t.getState());\n    t.start();\n    System.out.println("start() 后，Thread T 线程状态:"+t.getState());\n    //join()等待该线程结束，然后才继续往下执行自身线程\n    t.join();\n    System.out.println("join() 后，Thread T 状态:"+t.getState());\n    System.out.println("程序结束");\n}\n')])])]),n("p",[t._v("log")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("start() 前，Thread T 状态:NEW\nstart() 后，Thread T 线程状态:RUNNABLE\njoin() 后，Thread T 状态:TERMINATED\n")])])]),n("p",[t._v("如果上述示例不加 "),n("code",[t._v("join")]),t._v(", "),n("code",[t._v("Thread Main")]),t._v(" 将不会等待 "),n("code",[t._v("Thread t")]),t._v(" 执行，从而导致程序直接退出。")])]),t._v(" "),n("h3",{attrs:{id:"中断线程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#中断线程"}},[t._v("#")]),t._v(" 中断线程")]),t._v(" "),n("p",[n("code",[t._v("interrupt();")]),t._v(" 需要注意的是，他并不会直接中断线程，需要线程内部监听 "),n("code",[t._v("isInterrupted()")]),t._v(" 返回值")]),t._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[t._v("示例")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('Thread t = new Thread(() -> {\n    System.out.println("Thread t："+Thread.currentThread().getState());;\n    //监听是否中断\n    while (!Thread.currentThread().isInterrupted()){\n        System.out.println("正在运行中。。。"+ false);\n    }\n});\n\nt.start();\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    throw new RuntimeException(e);\n}\n//线程中断\nt.interrupt();\ntry {\n    //等待检查执行完毕\n    t.join();\n} catch (InterruptedException e) {\n    System.out.println("程序已经 interrupt()");\n}\n\nSystem.out.println("程序结束");\n')])])])]),t._v(" "),n("h3",{attrs:{id:"守护线程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#守护线程"}},[t._v("#")]),t._v(" 守护线程")]),t._v(" "),n("p",[t._v("java程序的所有线程都是由jvm创建的，也就是说，只要有任意一个jvm创建的线程没有退出，那么jvm就不会退出。")]),t._v(" "),n("p",[t._v("所以线程需要有负责人对他进行关闭，但是一些线程，例如定时任务通常是无线循环，且无人它负责的关闭。")]),t._v(" "),n("p",[t._v("这类线程需要随着系统的退出而关闭,对于这类线程通常会用到守护线程。")]),t._v(" "),n("p",[t._v("需要注意的是：")]),t._v(" "),n("p",[n("strong",[t._v("守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。")])]),t._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[t._v("示例")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('Thread thread = new Thread(() -> {\n    while (true){\n    }\n});\n//设置守护线程\nthread.setDaemon(true);\nthread.start();\n\nSystem.out.println("程序结束"));\n')])])])]),t._v(" "),n("h3",{attrs:{id:"线程同步"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程同步"}},[t._v("#")]),t._v(" 线程同步")]),t._v(" "),n("p",[t._v("多线程的模式下，对同一个模型进行操作，结果往往不尽如意,例如一以下示例：")]),t._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[t._v("示例")]),t._v(" "),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[t._v("\nstatic int n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\npublic static void main"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("String"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    Thread a  "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Thread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("-"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("int i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i++"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n             n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n++"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    Thread b "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Thread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" -"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("int i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i++"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n--"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    b.start"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    a.start"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    try "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        a.join"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        b.join"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" catch "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("InterruptedException e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        throw new RuntimeException"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    System.out.println"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),n("p",[t._v("上述程序中: A，B两个线程分别对"),n("code",[t._v("n")]),t._v("进行了1000次加，减操作。按照预期最终结果应该为:0。")]),t._v(" "),n("p",[t._v("实际上并不是这样，"),n("code",[t._v("n = n++;")]),t._v(" 这行代码实际上分为3个步骤")]),t._v(" "),n("ol",[n("li",[t._v("ILOAD")]),t._v(" "),n("li",[t._v("IADD")]),t._v(" "),n("li",[t._v("ISTORE")])]),t._v(" "),n("p",[t._v("例如: n=10 ,n=n++; 对应的步骤是：")]),t._v(" "),n("ol",[n("li",[t._v("ILOAD -> n=10")]),t._v(" "),n("li",[t._v("IADD  ->  +1操作")]),t._v(" "),n("li",[t._v("ISTORE -> n=11")])]),t._v(" "),n("p",[t._v("但是有这样一种场景: A线程对N进行+1操作, 在没有到 "),n("code",[t._v("ISTORE")]),t._v(" 阶段时, B线程对N进行-1操作，"),n("code",[t._v("ILOAD")]),t._v(" 得到的是为变更结果")]),t._v(" "),n("p",[t._v("代入上面推断")]),t._v(" "),n("ol",[n("li",[t._v("A -> 10 +1 -> 11")]),t._v(" "),n("li",[t._v("B -> 10 -1 -> 9")]),t._v(" "),n("li",[t._v("最终结果：n=9")])]),t._v(" "),n("p",[t._v("所以上述程序有时候的得不到预期的结果:0")]),t._v(" "),n("p",[t._v("为了解决上述问题，我们需要保证，在进行一次变更操作的时候，别的线程不能干扰它，也就是阻断别的线程。")]),t._v(" "),n("p",[t._v("可通过 "),n("code",[t._v("synchronized")]),t._v(" 关键字对"),n("strong",[t._v("一个对象")]),t._v("进行加锁,保证了代码块在任意时刻最多只有一个线程能执行。")]),t._v(" "),n("p",[t._v("改动代码如下")]),t._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[t._v("示例")]),t._v(" "),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[t._v("static int n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n//锁对象\nstatic final Object LOCK "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Object"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\npublic static void main"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("String"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n\n    Thread a  "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Thread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("-"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("int i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i++"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            synchronized "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LOCK"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n++"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    Thread b "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Thread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" -"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("int i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i++"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            synchronized "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LOCK"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n--"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    b.start"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    a.start"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    try "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        a.join"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        b.join"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" catch "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("InterruptedException e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        throw new RuntimeException"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    System.out.println"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),n("p",[n("code",[t._v("synchronized")]),t._v(" 保证了代码块中数据的原子性，同样JVM规范定义了几种原子操作 ：")]),t._v(" "),n("ul",[n("li",[t._v("基本类型赋值 （long和double除外）\n"),n("ul",[n("li",[t._v("例如："),n("code",[t._v("int n = m")])])])]),t._v(" "),n("li",[t._v("引用类型赋值:\n"),n("ul",[n("li",[t._v("例如："),n("code",[t._v("List<String> list = anotherList")])])])]),t._v(" "),n("li",[t._v("不可变对象无需同步")])]),t._v(" "),n("p",[t._v("同样使用 "),n("code",[t._v("synchronized")]),t._v(" 需要注意粒度，对于一个锁对象，应该应用于同类事务。不同类事务的操作，应该定义与之对应的锁对象。")]),t._v(" "),n("p",[t._v("例如：分别统计男女性别数量")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int boyCount=0;\nint girlCount=0\nstatic final Object LOCK = new Object();\n\naddBoy(){\n  synchronized (LOCK){\n    boyCount= boyCount++;\n  }\n}\n\naddGirl(){\n  synchronized (LOCK){\n    girlCount= girlCount++;\n  }\n}\n")])])]),n("p",[t._v("都是进行+1操作。如果同一把锁进行保证同步，那么将会损失一部分性能。因为这两个统计是可以分开进行的,这类场景就可以男女分别设置一把锁。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int boyCount=0;\nint girlCount=0\nstatic final Object BOY_LOCK = new Object();\nstatic final Object GIRL_LOCK = new Object();\n\nvoid addBoy(){\n  synchronized (BOY_LOCK){\n    boyCount= boyCount++;\n  }\n}\n\nvoid addGirl(){\n  synchronized (GIRL_LOCK){\n    girlCount= girlCount++;\n  }\n}\n")])])]),n("h3",{attrs:{id:"同步方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同步方法"}},[t._v("#")]),t._v(" 同步方法")]),t._v(" "),n("p",[t._v("在使用"),n("code",[t._v("synchronized")]),t._v("对线程进行同步，使用synchronized的时候，锁住的是哪个对象非常重要。")]),t._v(" "),n("p",[t._v("但是在方法内定于过多的锁对象，会使代码变得凌乱且不易于维护。")]),t._v(" "),n("p",[t._v("对于大部分方法而言，我们想要的通常是:使用一个"),n("strong",[t._v("实例对象")]),t._v("调用方法时，不被别的线程调用"),n("strong",[t._v("同一个实例对象")]),t._v("所影响，因此我们需要锁住的其实是这个实例本身。")]),t._v(" "),n("p",[t._v("锁住实例本身有两种方式，他们效果相同：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int boyCount=0;\n\nvoid addBoy(){\n  synchronized (this){\n    boyCount= boyCount++;\n  }\n}\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int boyCount=0;\n\nsynchronized void addBoy(){\n   (this){\n    boyCount= boyCount++;\n  }\n}\n\n")])])]),n("p",[t._v("因此，用 "),n("code",[t._v("synchronized")]),t._v(" 修饰的方法就是同步方法，它表示整个方法都必须用"),n("code",[t._v("this实例")]),t._v("加锁。")]),t._v(" "),n("p",[t._v("当调用的是静态方法时：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public class Test {\n    public synchronized void test(int n) {\n    \n    }\n}\n")])])]),n("p",[t._v("由于静态方法没有 "),n("code",[t._v("this")]),t._v(" 对象，它锁住的是当前的"),n("code",[t._v("Class实例")]),t._v("，由jvm创建 ，因此静态方法的同步也可以这样写")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public class Test {\n    public static void test(int n) {\n        synchronized(Test.class) {\n            \n        }\n    }\n}\n")])])]),n("h3",{attrs:{id:"可重入锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁"}},[t._v("#")]),t._v(" 可重入锁")]),t._v(" "),n("p",[n("code",[t._v("synchronized")]),t._v("  代码块所加的锁为可重入锁，也就是说，在获取到当前对象的锁后，可以继续获取同一个锁。")]),t._v(" "),n("p",[t._v("如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public class Test {\n    public synchronized void test(int n) { //得到锁\n        test2(n);\n    }//释放锁\n    \n    public synchronized void test2(int n) {//得到锁 \n\n    }//释放锁\n}\n")])])]),n("p",[t._v("可重入锁在获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出"),n("code",[t._v("synchronized")]),t._v("块，记录-1，减到0的时候，才会真正释放锁。")]),t._v(" "),n("h3",{attrs:{id:"死锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),n("p",[t._v("死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待。")]),t._v(" "),n("p",[t._v("由于 "),n("code",[t._v("synchronized")]),t._v(" 为可重入锁，那么在如下程序")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('public  class Test {\n    static  final Object LOCK_1 = new Object();\n    static  final Object LOCK_2 = new Object();\n    \n    public  void test1(int n) { //得到锁\n        System.out.println("得到方法test1的锁");\n        synchronized (LOCK_1){\n            test2(n);\n            synchronized (LOCK_2){\n                System.out.println("test1");\n            }\n        }\n    }//释放锁\n\n    public  void test2(int n) {//得到锁\n        System.out.println("得到方法test1的锁");\n        synchronized (LOCK_2){\n            test1(n);\n            synchronized (LOCK_1){\n                System.out.println("test2");\n            }\n        }\n    }//释放锁\n\n}\n\n')])])]),n("p",[t._v("此时如果有两个线程A,B。")]),t._v(" "),n("p",[t._v("A 调用了"),n("code",[t._v("test1")]),t._v(" 拿到了锁 "),n("code",[t._v("LOCK_1")]),t._v(" ,准备获取"),n("code",[t._v("LOCK_2")]),t._v("。")]),t._v(" "),n("p",[t._v("于此同时，B 调用了"),n("code",[t._v("test2")]),t._v(" 拿到了锁 "),n("code",[t._v("LOCK_2")]),t._v(" ,准备获取"),n("code",[t._v("LOCK_1")]),t._v("。")]),t._v(" "),n("p",[t._v("这时候 "),n("code",[t._v("test2")]),t._v(" 无法获取 "),n("code",[t._v("LOCK_1")]),t._v(" ,"),n("code",[t._v("test1")]),t._v(" 无法获取 "),n("code",[t._v("LOCK_2")]),t._v(" , 双方都在等待对方释放锁。导致形成死锁。")]),t._v(" "),n("p",[n("strong",[t._v("所以多线程获取锁的顺序要一致，以避免出现死锁。")])])])}),[],!1,null,null,null);n.default=e.exports}}]);